/* tslint:disable */
/* eslint-disable */
/**
 * MindHub User API
 * The user API to the MindHub system
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateInterestDto
 */
export interface CreateInterestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateInterestDto
     */
    'relevance': CreateInterestDtoRelevanceEnum;
    /**
     * 
     * @type {ResourceDto}
     * @memberof CreateInterestDto
     */
    'resource': ResourceDto;
}

export const CreateInterestDtoRelevanceEnum = {
    Normal: 'normal',
    Favorite: 'favorite'
} as const;

export type CreateInterestDtoRelevanceEnum = typeof CreateInterestDtoRelevanceEnum[keyof typeof CreateInterestDtoRelevanceEnum];

/**
 * 
 * @export
 * @interface CreateTextDto
 */
export interface CreateTextDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTextDto
     */
    'rawText': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTextDto
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface FriendshipDto
 */
export interface FriendshipDto {
    /**
     * 
     * @type {SharedUserInfo}
     * @memberof FriendshipDto
     */
    'user': SharedUserInfo;
    /**
     * 
     * @type {RecommendationScore}
     * @memberof FriendshipDto
     */
    'score': RecommendationScore;
}
/**
 * 
 * @export
 * @interface GetFriendshipsResDto
 */
export interface GetFriendshipsResDto {
    /**
     * 
     * @type {Array<FriendshipDto>}
     * @memberof GetFriendshipsResDto
     */
    'friends': Array<FriendshipDto>;
}
/**
 * 
 * @export
 * @interface GetGivenRatesResDto
 */
export interface GetGivenRatesResDto {
    /**
     * 
     * @type {Array<GivenRateDto>}
     * @memberof GetGivenRatesResDto
     */
    'rates': Array<GivenRateDto>;
}
/**
 * 
 * @export
 * @interface GetMessagesResDto
 */
export interface GetMessagesResDto {
    /**
     * 
     * @type {Array<MessageDto>}
     * @memberof GetMessagesResDto
     */
    'messages': Array<MessageDto>;
}
/**
 * 
 * @export
 * @interface GetOwnUserResDto
 */
export interface GetOwnUserResDto {
    /**
     * 
     * @type {Profile}
     * @memberof GetOwnUserResDto
     */
    'profile': Profile;
    /**
     * 
     * @type {string}
     * @memberof GetOwnUserResDto
     */
    'signupState': GetOwnUserResDtoSignupStateEnum;
}

export const GetOwnUserResDtoSignupStateEnum = {
    PendingProfile: 'pending_profile',
    PendingProviders: 'pending_providers',
    PendingRecommendations: 'pending_recommendations',
    Active: 'active'
} as const;

export type GetOwnUserResDtoSignupStateEnum = typeof GetOwnUserResDtoSignupStateEnum[keyof typeof GetOwnUserResDtoSignupStateEnum];

/**
 * 
 * @export
 * @interface GetProviderConnsResDto
 */
export interface GetProviderConnsResDto {
    /**
     * 
     * @type {Array<ProviderConnectionDto>}
     * @memberof GetProviderConnsResDto
     */
    'connections': Array<ProviderConnectionDto>;
}
/**
 * 
 * @export
 * @interface GetRecommendationsResDto
 */
export interface GetRecommendationsResDto {
    /**
     * 
     * @type {Array<RecommendationDto>}
     * @memberof GetRecommendationsResDto
     */
    'recommendations': Array<RecommendationDto>;
    /**
     * 
     * @type {number}
     * @memberof GetRecommendationsResDto
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetRecommendationsResDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetSharedInterestsResDto
 */
export interface GetSharedInterestsResDto {
    /**
     * 
     * @type {Array<SharedInterestDto>}
     * @memberof GetSharedInterestsResDto
     */
    'sharedInterests': Array<SharedInterestDto>;
}
/**
 * 
 * @export
 * @interface GetUserInterestsResDto
 */
export interface GetUserInterestsResDto {
    /**
     * 
     * @type {Array<UserInterestDto>}
     * @memberof GetUserInterestsResDto
     */
    'interests': Array<UserInterestDto>;
    /**
     * 
     * @type {number}
     * @memberof GetUserInterestsResDto
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserInterestsResDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetUserTextsResDto
 */
export interface GetUserTextsResDto {
    /**
     * 
     * @type {Array<UserTextDto>}
     * @memberof GetUserTextsResDto
     */
    'texts': Array<UserTextDto>;
    /**
     * 
     * @type {number}
     * @memberof GetUserTextsResDto
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserTextsResDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GivenRateDto
 */
export interface GivenRateDto {
    /**
     * 
     * @type {string}
     * @memberof GivenRateDto
     */
    'rateeId': string;
    /**
     * 
     * @type {number}
     * @memberof GivenRateDto
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: string;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface MessageDto
 */
export interface MessageDto {
    /**
     * 
     * @type {boolean}
     * @memberof MessageDto
     */
    'isOwn': boolean;
    /**
     * 
     * @type {string}
     * @memberof MessageDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MessageDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PostMessageDto
 */
export interface PostMessageDto {
    /**
     * 
     * @type {string}
     * @memberof PostMessageDto
     */
    'receiverId': string;
    /**
     * 
     * @type {string}
     * @memberof PostMessageDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PostRateDto
 */
export interface PostRateDto {
    /**
     * 
     * @type {string}
     * @memberof PostRateDto
     */
    'rateeId': string;
    /**
     * 
     * @type {number}
     * @memberof PostRateDto
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'gender': ProfileGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'birthday': string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'biography'?: string;
}

export const ProfileGenderEnum = {
    Man: 'man',
    Woman: 'woman',
    Other: 'other'
} as const;

export type ProfileGenderEnum = typeof ProfileGenderEnum[keyof typeof ProfileGenderEnum];

/**
 * 
 * @export
 * @interface ProfileDto
 */
export interface ProfileDto {
    /**
     * 
     * @type {string}
     * @memberof ProfileDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileDto
     */
    'gender': ProfileDtoGenderEnum;
    /**
     * 
     * @type {number}
     * @memberof ProfileDto
     */
    'age': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileDto
     */
    'biography'?: string;
}

export const ProfileDtoGenderEnum = {
    Man: 'man',
    Woman: 'woman',
    Other: 'other'
} as const;

export type ProfileDtoGenderEnum = typeof ProfileDtoGenderEnum[keyof typeof ProfileDtoGenderEnum];

/**
 * 
 * @export
 * @interface ProposeFriendshipDto
 */
export interface ProposeFriendshipDto {
    /**
     * 
     * @type {string}
     * @memberof ProposeFriendshipDto
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ProviderConnectionDto
 */
export interface ProviderConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDto
     */
    'provider': string;
    /**
     * 
     * @type {ProviderConnectionDtoOauth}
     * @memberof ProviderConnectionDto
     */
    'oauth': ProviderConnectionDtoOauth;
    /**
     * 
     * @type {ProviderConnectionDtoOauth}
     * @memberof ProviderConnectionDto
     */
    'file': ProviderConnectionDtoOauth;
}
/**
 * 
 * @export
 * @interface ProviderConnectionDtoOauth
 */
export interface ProviderConnectionDtoOauth {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoOauth
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface RecommendationDto
 */
export interface RecommendationDto {
    /**
     * 
     * @type {SharedUserInfo}
     * @memberof RecommendationDto
     */
    'user': SharedUserInfo;
    /**
     * 
     * @type {RecommendationScore}
     * @memberof RecommendationDto
     */
    'score': RecommendationScore;
}
/**
 * 
 * @export
 * @interface RecommendationScore
 */
export interface RecommendationScore {
    /**
     * 
     * @type {number}
     * @memberof RecommendationScore
     */
    'global': number;
    /**
     * 
     * @type {object}
     * @memberof RecommendationScore
     */
    'friendship': object;
    /**
     * 
     * @type {object}
     * @memberof RecommendationScore
     */
    'interests': object;
}
/**
 * 
 * @export
 * @interface RelevanceDto
 */
export interface RelevanceDto {
    /**
     * 
     * @type {string}
     * @memberof RelevanceDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RelevanceDto
     */
    'relevance': RelevanceDtoRelevanceEnum;
}

export const RelevanceDtoRelevanceEnum = {
    Normal: 'normal',
    Favorite: 'favorite'
} as const;

export type RelevanceDtoRelevanceEnum = typeof RelevanceDtoRelevanceEnum[keyof typeof RelevanceDtoRelevanceEnum];

/**
 * 
 * @export
 * @interface ResourceDto
 */
export interface ResourceDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDto
     */
    'type': ResourceDtoTypeEnum;
}

export const ResourceDtoTypeEnum = {
    Track: 'track',
    Artist: 'artist'
} as const;

export type ResourceDtoTypeEnum = typeof ResourceDtoTypeEnum[keyof typeof ResourceDtoTypeEnum];

/**
 * 
 * @export
 * @interface ReviewRecommendationReqDto
 */
export interface ReviewRecommendationReqDto {
    /**
     * 
     * @type {boolean}
     * @memberof ReviewRecommendationReqDto
     */
    'accept': boolean;
}
/**
 * 
 * @export
 * @interface ReviewRequestDto
 */
export interface ReviewRequestDto {
    /**
     * 
     * @type {boolean}
     * @memberof ReviewRequestDto
     */
    'accept': boolean;
}
/**
 * 
 * @export
 * @interface SharedInterestDto
 */
export interface SharedInterestDto {
    /**
     * 
     * @type {ResourceDto}
     * @memberof SharedInterestDto
     */
    'resource': ResourceDto;
    /**
     * 
     * @type {Array<RelevanceDto>}
     * @memberof SharedInterestDto
     */
    'relevances': Array<RelevanceDto>;
}
/**
 * 
 * @export
 * @interface SharedUserInfo
 */
export interface SharedUserInfo {
    /**
     * 
     * @type {string}
     * @memberof SharedUserInfo
     */
    '_id': string;
    /**
     * 
     * @type {ProfileDto}
     * @memberof SharedUserInfo
     */
    'profile': ProfileDto;
    /**
     * 
     * @type {number}
     * @memberof SharedUserInfo
     */
    'inactiveHours': number;
    /**
     * 
     * @type {number}
     * @memberof SharedUserInfo
     */
    'distance'?: number;
    /**
     * 
     * @type {Array<SharedInterestDto>}
     * @memberof SharedUserInfo
     */
    'sharedInterests'?: Array<SharedInterestDto>;
    /**
     * 
     * @type {UserPersonalityDto}
     * @memberof SharedUserInfo
     */
    'personality'?: UserPersonalityDto;
    /**
     * 
     * @type {number}
     * @memberof SharedUserInfo
     */
    'rating'?: number;
}
/**
 * 
 * @export
 * @interface SignupReqDto
 */
export interface SignupReqDto {
    /**
     * 
     * @type {string}
     * @memberof SignupReqDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UpdateLastConnectionReqDto
 */
export interface UpdateLastConnectionReqDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateLastConnectionReqDto
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateLastConnectionReqDto
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface UpdateProfileReqDto
 */
export interface UpdateProfileReqDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileReqDto
     */
    'gender': UpdateProfileReqDtoGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileReqDto
     */
    'birthday': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileReqDto
     */
    'biography'?: string;
}

export const UpdateProfileReqDtoGenderEnum = {
    Man: 'man',
    Woman: 'woman',
    Other: 'other'
} as const;

export type UpdateProfileReqDtoGenderEnum = typeof UpdateProfileReqDtoGenderEnum[keyof typeof UpdateProfileReqDtoGenderEnum];

/**
 * 
 * @export
 * @interface UserInterestDto
 */
export interface UserInterestDto {
    /**
     * 
     * @type {string}
     * @memberof UserInterestDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInterestDto
     */
    'provider': UserInterestDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserInterestDto
     */
    'relevance': UserInterestDtoRelevanceEnum;
    /**
     * 
     * @type {ResourceDto}
     * @memberof UserInterestDto
     */
    'resource': ResourceDto;
    /**
     * 
     * @type {string}
     * @memberof UserInterestDto
     */
    'date': string;
}

export const UserInterestDtoProviderEnum = {
    Spotify: 'spotify',
    Twitter: 'twitter',
    User: 'user'
} as const;

export type UserInterestDtoProviderEnum = typeof UserInterestDtoProviderEnum[keyof typeof UserInterestDtoProviderEnum];
export const UserInterestDtoRelevanceEnum = {
    Normal: 'normal',
    Favorite: 'favorite'
} as const;

export type UserInterestDtoRelevanceEnum = typeof UserInterestDtoRelevanceEnum[keyof typeof UserInterestDtoRelevanceEnum];

/**
 * 
 * @export
 * @interface UserPersonalityDto
 */
export interface UserPersonalityDto {
    /**
     * 
     * @type {string}
     * @memberof UserPersonalityDto
     */
    'userId'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserPersonalityDto
     */
    'o': number;
    /**
     * 
     * @type {number}
     * @memberof UserPersonalityDto
     */
    'c': number;
    /**
     * 
     * @type {number}
     * @memberof UserPersonalityDto
     */
    'e': number;
    /**
     * 
     * @type {number}
     * @memberof UserPersonalityDto
     */
    'a': number;
    /**
     * 
     * @type {number}
     * @memberof UserPersonalityDto
     */
    'n': number;
}
/**
 * 
 * @export
 * @interface UserTextDto
 */
export interface UserTextDto {
    /**
     * 
     * @type {string}
     * @memberof UserTextDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserTextDto
     */
    'provider': UserTextDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTextDto
     */
    'rawText': string;
    /**
     * 
     * @type {string}
     * @memberof UserTextDto
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof UserTextDto
     */
    'date'?: string;
}

export const UserTextDtoProviderEnum = {
    Spotify: 'spotify',
    Twitter: 'twitter',
    User: 'user'
} as const;

export type UserTextDtoProviderEnum = typeof UserTextDtoProviderEnum[keyof typeof UserTextDtoProviderEnum];


/**
 * FriendshipsApi - axios parameter creator
 * @export
 */
export const FriendshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get friendships, either accepted ones, or sent/received requests
         * @param {Array<string>} optionalFields 
         * @param {FriendshipsControllerGetFriendshipsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerGetFriendships: async (optionalFields: Array<string>, type: FriendshipsControllerGetFriendshipsTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionalFields' is not null or undefined
            assertParamExists('friendshipsControllerGetFriendships', 'optionalFields', optionalFields)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('friendshipsControllerGetFriendships', 'type', type)
            const localVarPath = `/friendships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (optionalFields) {
                localVarQueryParameter['optionalFields[]'] = optionalFields;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a friendship request
         * @param {ProposeFriendshipDto} proposeFriendshipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerProposeFriendship: async (proposeFriendshipDto: ProposeFriendshipDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposeFriendshipDto' is not null or undefined
            assertParamExists('friendshipsControllerProposeFriendship', 'proposeFriendshipDto', proposeFriendshipDto)
            const localVarPath = `/friendships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proposeFriendshipDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept or reject a friendship request
         * @param {string} proposerId 
         * @param {ReviewRequestDto} reviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerReviewRequest: async (proposerId: string, reviewRequestDto: ReviewRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposerId' is not null or undefined
            assertParamExists('friendshipsControllerReviewRequest', 'proposerId', proposerId)
            // verify required parameter 'reviewRequestDto' is not null or undefined
            assertParamExists('friendshipsControllerReviewRequest', 'reviewRequestDto', reviewRequestDto)
            const localVarPath = `/friendships/{proposerId}`
                .replace(`{${"proposerId"}}`, encodeURIComponent(String(proposerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendshipsApi - functional programming interface
 * @export
 */
export const FriendshipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FriendshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get friendships, either accepted ones, or sent/received requests
         * @param {Array<string>} optionalFields 
         * @param {FriendshipsControllerGetFriendshipsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async friendshipsControllerGetFriendships(optionalFields: Array<string>, type: FriendshipsControllerGetFriendshipsTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFriendshipsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.friendshipsControllerGetFriendships(optionalFields, type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FriendshipsApi.friendshipsControllerGetFriendships']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Send a friendship request
         * @param {ProposeFriendshipDto} proposeFriendshipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async friendshipsControllerProposeFriendship(proposeFriendshipDto: ProposeFriendshipDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.friendshipsControllerProposeFriendship(proposeFriendshipDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FriendshipsApi.friendshipsControllerProposeFriendship']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Accept or reject a friendship request
         * @param {string} proposerId 
         * @param {ReviewRequestDto} reviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async friendshipsControllerReviewRequest(proposerId: string, reviewRequestDto: ReviewRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.friendshipsControllerReviewRequest(proposerId, reviewRequestDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FriendshipsApi.friendshipsControllerReviewRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FriendshipsApi - factory interface
 * @export
 */
export const FriendshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FriendshipsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get friendships, either accepted ones, or sent/received requests
         * @param {Array<string>} optionalFields 
         * @param {FriendshipsControllerGetFriendshipsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerGetFriendships(optionalFields: Array<string>, type: FriendshipsControllerGetFriendshipsTypeEnum, options?: any): AxiosPromise<GetFriendshipsResDto> {
            return localVarFp.friendshipsControllerGetFriendships(optionalFields, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a friendship request
         * @param {ProposeFriendshipDto} proposeFriendshipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerProposeFriendship(proposeFriendshipDto: ProposeFriendshipDto, options?: any): AxiosPromise<void> {
            return localVarFp.friendshipsControllerProposeFriendship(proposeFriendshipDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept or reject a friendship request
         * @param {string} proposerId 
         * @param {ReviewRequestDto} reviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendshipsControllerReviewRequest(proposerId: string, reviewRequestDto: ReviewRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.friendshipsControllerReviewRequest(proposerId, reviewRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FriendshipsApi - object-oriented interface
 * @export
 * @class FriendshipsApi
 * @extends {BaseAPI}
 */
export class FriendshipsApi extends BaseAPI {
    /**
     * 
     * @summary Get friendships, either accepted ones, or sent/received requests
     * @param {Array<string>} optionalFields 
     * @param {FriendshipsControllerGetFriendshipsTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipsApi
     */
    public friendshipsControllerGetFriendships(optionalFields: Array<string>, type: FriendshipsControllerGetFriendshipsTypeEnum, options?: AxiosRequestConfig) {
        return FriendshipsApiFp(this.configuration).friendshipsControllerGetFriendships(optionalFields, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a friendship request
     * @param {ProposeFriendshipDto} proposeFriendshipDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipsApi
     */
    public friendshipsControllerProposeFriendship(proposeFriendshipDto: ProposeFriendshipDto, options?: AxiosRequestConfig) {
        return FriendshipsApiFp(this.configuration).friendshipsControllerProposeFriendship(proposeFriendshipDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept or reject a friendship request
     * @param {string} proposerId 
     * @param {ReviewRequestDto} reviewRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipsApi
     */
    public friendshipsControllerReviewRequest(proposerId: string, reviewRequestDto: ReviewRequestDto, options?: AxiosRequestConfig) {
        return FriendshipsApiFp(this.configuration).friendshipsControllerReviewRequest(proposerId, reviewRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FriendshipsControllerGetFriendshipsTypeEnum = {
    Proposed: 'proposed',
    Received: 'received',
    Established: 'established'
} as const;
export type FriendshipsControllerGetFriendshipsTypeEnum = typeof FriendshipsControllerGetFriendshipsTypeEnum[keyof typeof FriendshipsControllerGetFriendshipsTypeEnum];


/**
 * HealthcheckApi - axios parameter creator
 * @export
 */
export const HealthcheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthcheckApi - functional programming interface
 * @export
 */
export const HealthcheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthcheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['HealthcheckApi.healthControllerCheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * HealthcheckApi - factory interface
 * @export
 */
export const HealthcheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthcheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: any): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthcheckApi - object-oriented interface
 * @export
 * @class HealthcheckApi
 * @extends {BaseAPI}
 */
export class HealthcheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthcheckApi
     */
    public healthControllerCheck(options?: AxiosRequestConfig) {
        return HealthcheckApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InterestsApi - axios parameter creator
 * @export
 */
export const InterestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an interest relationship
         * @param {CreateInterestDto} createInterestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerCreate: async (createInterestDto: CreateInterestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInterestDto' is not null or undefined
            assertParamExists('interestsControllerCreate', 'createInterestDto', createInterestDto)
            const localVarPath = `/interests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInterestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an interest relationship
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('interestsControllerDelete', 'id', id)
            const localVarPath = `/interests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the interests of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerGetOwn: async (offset: number, limit: number, resourceName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('interestsControllerGetOwn', 'offset', offset)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('interestsControllerGetOwn', 'limit', limit)
            const localVarPath = `/interests/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get interests of a user that are shared with the ones of the authenticated user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerGetShared: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('interestsControllerGetShared', 'userId', userId)
            const localVarPath = `/interests/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterestsApi - functional programming interface
 * @export
 */
export const InterestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an interest relationship
         * @param {CreateInterestDto} createInterestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interestsControllerCreate(createInterestDto: CreateInterestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interestsControllerCreate(createInterestDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InterestsApi.interestsControllerCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an interest relationship
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interestsControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interestsControllerDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InterestsApi.interestsControllerDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the interests of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interestsControllerGetOwn(offset: number, limit: number, resourceName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserInterestsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interestsControllerGetOwn(offset, limit, resourceName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InterestsApi.interestsControllerGetOwn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get interests of a user that are shared with the ones of the authenticated user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interestsControllerGetShared(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSharedInterestsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interestsControllerGetShared(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InterestsApi.interestsControllerGetShared']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InterestsApi - factory interface
 * @export
 */
export const InterestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterestsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an interest relationship
         * @param {CreateInterestDto} createInterestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerCreate(createInterestDto: CreateInterestDto, options?: any): AxiosPromise<void> {
            return localVarFp.interestsControllerCreate(createInterestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an interest relationship
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.interestsControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the interests of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerGetOwn(offset: number, limit: number, resourceName?: string, options?: any): AxiosPromise<GetUserInterestsResDto> {
            return localVarFp.interestsControllerGetOwn(offset, limit, resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get interests of a user that are shared with the ones of the authenticated user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestsControllerGetShared(userId: string, options?: any): AxiosPromise<GetSharedInterestsResDto> {
            return localVarFp.interestsControllerGetShared(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterestsApi - object-oriented interface
 * @export
 * @class InterestsApi
 * @extends {BaseAPI}
 */
export class InterestsApi extends BaseAPI {
    /**
     * 
     * @summary Create an interest relationship
     * @param {CreateInterestDto} createInterestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterestsApi
     */
    public interestsControllerCreate(createInterestDto: CreateInterestDto, options?: AxiosRequestConfig) {
        return InterestsApiFp(this.configuration).interestsControllerCreate(createInterestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an interest relationship
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterestsApi
     */
    public interestsControllerDelete(id: string, options?: AxiosRequestConfig) {
        return InterestsApiFp(this.configuration).interestsControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the interests of the authenticated user
     * @param {number} offset 
     * @param {number} limit 
     * @param {string} [resourceName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterestsApi
     */
    public interestsControllerGetOwn(offset: number, limit: number, resourceName?: string, options?: AxiosRequestConfig) {
        return InterestsApiFp(this.configuration).interestsControllerGetOwn(offset, limit, resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get interests of a user that are shared with the ones of the authenticated user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterestsApi
     */
    public interestsControllerGetShared(userId: string, options?: AxiosRequestConfig) {
        return InterestsApiFp(this.configuration).interestsControllerGetShared(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get messages with a specific user
         * @param {string} counterpartyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerGetMessages: async (counterpartyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'counterpartyId' is not null or undefined
            assertParamExists('messagesControllerGetMessages', 'counterpartyId', counterpartyId)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (counterpartyId !== undefined) {
                localVarQueryParameter['counterpartyId'] = counterpartyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message
         * @param {PostMessageDto} postMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerPostMessage: async (postMessageDto: PostMessageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postMessageDto' is not null or undefined
            assertParamExists('messagesControllerPostMessage', 'postMessageDto', postMessageDto)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postMessageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get messages with a specific user
         * @param {string} counterpartyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesControllerGetMessages(counterpartyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesControllerGetMessages(counterpartyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MessagesApi.messagesControllerGetMessages']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Send a message
         * @param {PostMessageDto} postMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesControllerPostMessage(postMessageDto: PostMessageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesControllerPostMessage(postMessageDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MessagesApi.messagesControllerPostMessage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get messages with a specific user
         * @param {string} counterpartyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerGetMessages(counterpartyId: string, options?: any): AxiosPromise<GetMessagesResDto> {
            return localVarFp.messagesControllerGetMessages(counterpartyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message
         * @param {PostMessageDto} postMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerPostMessage(postMessageDto: PostMessageDto, options?: any): AxiosPromise<void> {
            return localVarFp.messagesControllerPostMessage(postMessageDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Get messages with a specific user
     * @param {string} counterpartyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesControllerGetMessages(counterpartyId: string, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesControllerGetMessages(counterpartyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message
     * @param {PostMessageDto} postMessageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesControllerPostMessage(postMessageDto: PostMessageDto, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesControllerPostMessage(postMessageDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvidersApi - axios parameter creator
 * @export
 */
export const ProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the URL for starting the authentication flow
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (providerName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('authControllerLogin', 'providerName', providerName)
            const localVarPath = `/providers/{providerName}/login`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeem the obtained code to finalize authentication flow
         * @param {string} providerName 
         * @param {string} state 
         * @param {string} code 
         * @param {string} error 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRedeemCode: async (providerName: string, state: string, code: string, error: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('authControllerRedeemCode', 'providerName', providerName)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('authControllerRedeemCode', 'state', state)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('authControllerRedeemCode', 'code', code)
            // verify required parameter 'error' is not null or undefined
            assertParamExists('authControllerRedeemCode', 'error', error)
            const localVarPath = `/providers/{providerName}/redeemCode`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the connected providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsControllerGetConnections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the URL for uploading provider data file as a ZIP
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerGetFileUploadUrl: async (providerName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('fileControllerGetFileUploadUrl', 'providerName', providerName)
            const localVarPath = `/providers/{providerName}/fileUploadUrl`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the URL for starting the authentication flow
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(providerName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(providerName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProvidersApi.authControllerLogin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Redeem the obtained code to finalize authentication flow
         * @param {string} providerName 
         * @param {string} state 
         * @param {string} code 
         * @param {string} error 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRedeemCode(providerName: string, state: string, code: string, error: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRedeemCode(providerName, state, code, error, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProvidersApi.authControllerRedeemCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the connected providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectionsControllerGetConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProviderConnsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectionsControllerGetConnections(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProvidersApi.connectionsControllerGetConnections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the URL for uploading provider data file as a ZIP
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileControllerGetFileUploadUrl(providerName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileControllerGetFileUploadUrl(providerName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProvidersApi.fileControllerGetFileUploadUrl']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvidersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the URL for starting the authentication flow
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(providerName: string, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerLogin(providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeem the obtained code to finalize authentication flow
         * @param {string} providerName 
         * @param {string} state 
         * @param {string} code 
         * @param {string} error 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRedeemCode(providerName: string, state: string, code: string, error: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerRedeemCode(providerName, state, code, error, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the connected providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsControllerGetConnections(options?: any): AxiosPromise<GetProviderConnsResDto> {
            return localVarFp.connectionsControllerGetConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the URL for uploading provider data file as a ZIP
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerGetFileUploadUrl(providerName: string, options?: any): AxiosPromise<string> {
            return localVarFp.fileControllerGetFileUploadUrl(providerName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * 
     * @summary Get the URL for starting the authentication flow
     * @param {string} providerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public authControllerLogin(providerName: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).authControllerLogin(providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeem the obtained code to finalize authentication flow
     * @param {string} providerName 
     * @param {string} state 
     * @param {string} code 
     * @param {string} error 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public authControllerRedeemCode(providerName: string, state: string, code: string, error: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).authControllerRedeemCode(providerName, state, code, error, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the connected providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public connectionsControllerGetConnections(options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).connectionsControllerGetConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the URL for uploading provider data file as a ZIP
     * @param {string} providerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public fileControllerGetFileUploadUrl(providerName: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).fileControllerGetFileUploadUrl(providerName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RatesApi - axios parameter creator
 * @export
 */
export const RatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get given rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratesControllerGetGivenRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a rate
         * @param {PostRateDto} postRateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratesControllerPostRate: async (postRateDto: PostRateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postRateDto' is not null or undefined
            assertParamExists('ratesControllerPostRate', 'postRateDto', postRateDto)
            const localVarPath = `/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postRateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatesApi - functional programming interface
 * @export
 */
export const RatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get given rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratesControllerGetGivenRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGivenRatesResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratesControllerGetGivenRates(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatesApi.ratesControllerGetGivenRates']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Send a rate
         * @param {PostRateDto} postRateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratesControllerPostRate(postRateDto: PostRateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratesControllerPostRate(postRateDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatesApi.ratesControllerPostRate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RatesApi - factory interface
 * @export
 */
export const RatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get given rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratesControllerGetGivenRates(options?: any): AxiosPromise<GetGivenRatesResDto> {
            return localVarFp.ratesControllerGetGivenRates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a rate
         * @param {PostRateDto} postRateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratesControllerPostRate(postRateDto: PostRateDto, options?: any): AxiosPromise<void> {
            return localVarFp.ratesControllerPostRate(postRateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatesApi - object-oriented interface
 * @export
 * @class RatesApi
 * @extends {BaseAPI}
 */
export class RatesApi extends BaseAPI {
    /**
     * 
     * @summary Get given rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    public ratesControllerGetGivenRates(options?: AxiosRequestConfig) {
        return RatesApiFp(this.configuration).ratesControllerGetGivenRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a rate
     * @param {PostRateDto} postRateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatesApi
     */
    public ratesControllerPostRate(postRateDto: PostRateDto, options?: AxiosRequestConfig) {
        return RatesApiFp(this.configuration).ratesControllerPostRate(postRateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecommendationsApi - axios parameter creator
 * @export
 */
export const RecommendationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get friendship recommendations
         * @param {Array<string>} optionalFields 
         * @param {RecommendationsControllerGetRecommendationsPriorityEnum} priority 
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsControllerGetRecommendations: async (optionalFields: Array<string>, priority: RecommendationsControllerGetRecommendationsPriorityEnum, offset: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionalFields' is not null or undefined
            assertParamExists('recommendationsControllerGetRecommendations', 'optionalFields', optionalFields)
            // verify required parameter 'priority' is not null or undefined
            assertParamExists('recommendationsControllerGetRecommendations', 'priority', priority)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('recommendationsControllerGetRecommendations', 'offset', offset)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('recommendationsControllerGetRecommendations', 'limit', limit)
            const localVarPath = `/recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (optionalFields) {
                localVarQueryParameter['optionalFields[]'] = optionalFields;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept or discard a friendship recommendation
         * @param {string} recommendedUserId 
         * @param {ReviewRecommendationReqDto} reviewRecommendationReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsControllerReviewRecommendation: async (recommendedUserId: string, reviewRecommendationReqDto: ReviewRecommendationReqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recommendedUserId' is not null or undefined
            assertParamExists('recommendationsControllerReviewRecommendation', 'recommendedUserId', recommendedUserId)
            // verify required parameter 'reviewRecommendationReqDto' is not null or undefined
            assertParamExists('recommendationsControllerReviewRecommendation', 'reviewRecommendationReqDto', reviewRecommendationReqDto)
            const localVarPath = `/recommendations/{recommendedUserId}`
                .replace(`{${"recommendedUserId"}}`, encodeURIComponent(String(recommendedUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewRecommendationReqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecommendationsApi - functional programming interface
 * @export
 */
export const RecommendationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecommendationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get friendship recommendations
         * @param {Array<string>} optionalFields 
         * @param {RecommendationsControllerGetRecommendationsPriorityEnum} priority 
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendationsControllerGetRecommendations(optionalFields: Array<string>, priority: RecommendationsControllerGetRecommendationsPriorityEnum, offset: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecommendationsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendationsControllerGetRecommendations(optionalFields, priority, offset, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RecommendationsApi.recommendationsControllerGetRecommendations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Accept or discard a friendship recommendation
         * @param {string} recommendedUserId 
         * @param {ReviewRecommendationReqDto} reviewRecommendationReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendationsControllerReviewRecommendation(recommendedUserId: string, reviewRecommendationReqDto: ReviewRecommendationReqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendationsControllerReviewRecommendation(recommendedUserId, reviewRecommendationReqDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RecommendationsApi.recommendationsControllerReviewRecommendation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RecommendationsApi - factory interface
 * @export
 */
export const RecommendationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecommendationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get friendship recommendations
         * @param {Array<string>} optionalFields 
         * @param {RecommendationsControllerGetRecommendationsPriorityEnum} priority 
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsControllerGetRecommendations(optionalFields: Array<string>, priority: RecommendationsControllerGetRecommendationsPriorityEnum, offset: number, limit: number, options?: any): AxiosPromise<GetRecommendationsResDto> {
            return localVarFp.recommendationsControllerGetRecommendations(optionalFields, priority, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept or discard a friendship recommendation
         * @param {string} recommendedUserId 
         * @param {ReviewRecommendationReqDto} reviewRecommendationReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsControllerReviewRecommendation(recommendedUserId: string, reviewRecommendationReqDto: ReviewRecommendationReqDto, options?: any): AxiosPromise<void> {
            return localVarFp.recommendationsControllerReviewRecommendation(recommendedUserId, reviewRecommendationReqDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecommendationsApi - object-oriented interface
 * @export
 * @class RecommendationsApi
 * @extends {BaseAPI}
 */
export class RecommendationsApi extends BaseAPI {
    /**
     * 
     * @summary Get friendship recommendations
     * @param {Array<string>} optionalFields 
     * @param {RecommendationsControllerGetRecommendationsPriorityEnum} priority 
     * @param {number} offset 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public recommendationsControllerGetRecommendations(optionalFields: Array<string>, priority: RecommendationsControllerGetRecommendationsPriorityEnum, offset: number, limit: number, options?: AxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).recommendationsControllerGetRecommendations(optionalFields, priority, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept or discard a friendship recommendation
     * @param {string} recommendedUserId 
     * @param {ReviewRecommendationReqDto} reviewRecommendationReqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public recommendationsControllerReviewRecommendation(recommendedUserId: string, reviewRecommendationReqDto: ReviewRecommendationReqDto, options?: AxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).recommendationsControllerReviewRecommendation(recommendedUserId, reviewRecommendationReqDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RecommendationsControllerGetRecommendationsPriorityEnum = {
    Affinity: 'affinity',
    Distance: 'distance',
    Activity: 'activity'
} as const;
export type RecommendationsControllerGetRecommendationsPriorityEnum = typeof RecommendationsControllerGetRecommendationsPriorityEnum[keyof typeof RecommendationsControllerGetRecommendationsPriorityEnum];


/**
 * TextsApi - axios parameter creator
 * @export
 */
export const TextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a new text
         * @param {CreateTextDto} createTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerCreate: async (createTextDto: CreateTextDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTextDto' is not null or undefined
            assertParamExists('textsControllerCreate', 'createTextDto', createTextDto)
            const localVarPath = `/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a text
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textsControllerDelete', 'id', id)
            const localVarPath = `/texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the texts of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerGetOwn: async (offset: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('textsControllerGetOwn', 'offset', offset)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('textsControllerGetOwn', 'limit', limit)
            const localVarPath = `/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextsApi - functional programming interface
 * @export
 */
export const TextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a new text
         * @param {CreateTextDto} createTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textsControllerCreate(createTextDto: CreateTextDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textsControllerCreate(createTextDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TextsApi.textsControllerCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a text
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textsControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textsControllerDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TextsApi.textsControllerDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the texts of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textsControllerGetOwn(offset: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTextsResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textsControllerGetOwn(offset, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TextsApi.textsControllerGetOwn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TextsApi - factory interface
 * @export
 */
export const TextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextsApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a new text
         * @param {CreateTextDto} createTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerCreate(createTextDto: CreateTextDto, options?: any): AxiosPromise<void> {
            return localVarFp.textsControllerCreate(createTextDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a text
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textsControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the texts of the authenticated user
         * @param {number} offset 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textsControllerGetOwn(offset: number, limit: number, options?: any): AxiosPromise<GetUserTextsResDto> {
            return localVarFp.textsControllerGetOwn(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextsApi - object-oriented interface
 * @export
 * @class TextsApi
 * @extends {BaseAPI}
 */
export class TextsApi extends BaseAPI {
    /**
     * 
     * @summary Post a new text
     * @param {CreateTextDto} createTextDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public textsControllerCreate(createTextDto: CreateTextDto, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).textsControllerCreate(createTextDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a text
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public textsControllerDelete(id: string, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).textsControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the texts of the authenticated user
     * @param {number} offset 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public textsControllerGetOwn(offset: number, limit: number, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).textsControllerGetOwn(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get public information of a user
         * @param {string} id 
         * @param {Array<string>} optionalFields 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetById: async (id: string, optionalFields: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerGetById', 'id', id)
            // verify required parameter 'optionalFields' is not null or undefined
            assertParamExists('usersControllerGetById', 'optionalFields', optionalFields)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (optionalFields) {
                localVarQueryParameter['optionalFields[]'] = optionalFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetOwnUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a temporary URL for uploading picture
         * @param {string} fileMime 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPictureUploadUrl: async (fileMime: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileMime' is not null or undefined
            assertParamExists('usersControllerGetPictureUploadUrl', 'fileMime', fileMime)
            const localVarPath = `/users/me/pictureUploadUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileMime !== undefined) {
                localVarQueryParameter['fileMime'] = fileMime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up the user
         * @param {SignupReqDto} signupReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerSignupUser: async (signupReqDto: SignupReqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupReqDto' is not null or undefined
            assertParamExists('usersControllerSignupUser', 'signupReqDto', signupReqDto)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupReqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update authenticated user last connection
         * @param {UpdateLastConnectionReqDto} updateLastConnectionReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateLastConnection: async (updateLastConnectionReqDto: UpdateLastConnectionReqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLastConnectionReqDto' is not null or undefined
            assertParamExists('usersControllerUpdateLastConnection', 'updateLastConnectionReqDto', updateLastConnectionReqDto)
            const localVarPath = `/users/me/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLastConnectionReqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update authenticated user profile
         * @param {UpdateProfileReqDto} updateProfileReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateProfile: async (updateProfileReqDto: UpdateProfileReqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileReqDto' is not null or undefined
            assertParamExists('usersControllerUpdateProfile', 'updateProfileReqDto', updateProfileReqDto)
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileReqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get public information of a user
         * @param {string} id 
         * @param {Array<string>} optionalFields 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetById(id: string, optionalFields: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedUserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetById(id, optionalFields, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerGetById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetOwnUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOwnUserResDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetOwnUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerGetOwnUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a temporary URL for uploading picture
         * @param {string} fileMime 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetPictureUploadUrl(fileMime: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetPictureUploadUrl(fileMime, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerGetPictureUploadUrl']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up the user
         * @param {SignupReqDto} signupReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerSignupUser(signupReqDto: SignupReqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSignupUser(signupReqDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerSignupUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update authenticated user last connection
         * @param {UpdateLastConnectionReqDto} updateLastConnectionReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdateLastConnection(updateLastConnectionReqDto: UpdateLastConnectionReqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdateLastConnection(updateLastConnectionReqDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerUpdateLastConnection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update authenticated user profile
         * @param {UpdateProfileReqDto} updateProfileReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdateProfile(updateProfileReqDto: UpdateProfileReqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdateProfile(updateProfileReqDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersControllerUpdateProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get public information of a user
         * @param {string} id 
         * @param {Array<string>} optionalFields 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetById(id: string, optionalFields: Array<string>, options?: any): AxiosPromise<SharedUserInfo> {
            return localVarFp.usersControllerGetById(id, optionalFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetOwnUser(options?: any): AxiosPromise<GetOwnUserResDto> {
            return localVarFp.usersControllerGetOwnUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a temporary URL for uploading picture
         * @param {string} fileMime 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPictureUploadUrl(fileMime: string, options?: any): AxiosPromise<string> {
            return localVarFp.usersControllerGetPictureUploadUrl(fileMime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up the user
         * @param {SignupReqDto} signupReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerSignupUser(signupReqDto: SignupReqDto, options?: any): AxiosPromise<void> {
            return localVarFp.usersControllerSignupUser(signupReqDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update authenticated user last connection
         * @param {UpdateLastConnectionReqDto} updateLastConnectionReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateLastConnection(updateLastConnectionReqDto: UpdateLastConnectionReqDto, options?: any): AxiosPromise<void> {
            return localVarFp.usersControllerUpdateLastConnection(updateLastConnectionReqDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update authenticated user profile
         * @param {UpdateProfileReqDto} updateProfileReqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdateProfile(updateProfileReqDto: UpdateProfileReqDto, options?: any): AxiosPromise<void> {
            return localVarFp.usersControllerUpdateProfile(updateProfileReqDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get public information of a user
     * @param {string} id 
     * @param {Array<string>} optionalFields 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetById(id: string, optionalFields: Array<string>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetById(id, optionalFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get authenticated user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetOwnUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetOwnUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a temporary URL for uploading picture
     * @param {string} fileMime 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetPictureUploadUrl(fileMime: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetPictureUploadUrl(fileMime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up the user
     * @param {SignupReqDto} signupReqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerSignupUser(signupReqDto: SignupReqDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerSignupUser(signupReqDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update authenticated user last connection
     * @param {UpdateLastConnectionReqDto} updateLastConnectionReqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdateLastConnection(updateLastConnectionReqDto: UpdateLastConnectionReqDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdateLastConnection(updateLastConnectionReqDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update authenticated user profile
     * @param {UpdateProfileReqDto} updateProfileReqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdateProfile(updateProfileReqDto: UpdateProfileReqDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdateProfile(updateProfileReqDto, options).then((request) => request(this.axios, this.basePath));
    }
}



